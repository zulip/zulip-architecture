- ZAP PR: [zulip/zulip-architecture#2](https://github.com/zulip/zulip-architecture/pull/2)

# Summary

Proposal to add end-to-end encryption for mobile push notifications.

# Motivation

Currently, the Zulip Push Notification Forwarding Service receives
(but does not store or log) the contents of individual mobile push notifications.

Adding end-to-end encryption for push notifications will ensure that the
actual message content does not need to be readable by the push notification
bouncer (or Google/Apple's servers, for that matter).

# Detailed design

## High-Level Plan

- Client checks the server if it supports E2E encryption. If it doesn't,
  use the legacy push notification registration flow.

- Client generates an asymmetric key pair (public and private key).
  It stores the private key securely and makes an API call to the server
  with the public key to register itself for push notifications.

- While sending notification, the server encrypts the notification content
  to the public key from above and sends it to push bouncer.
  Push bouncer forwards it to FCM/APNs.

- Client receives the notification via FCM/APNs and decrypts the content
  using the private key it stored earlier.

## Data model

- On the client, include the following fields on [the Account type](https://github.com/zulip/zulip-flutter/blob/ec9aa351b3050a0fa3e467007826576110fdbf99/lib/model/database.dart#L66-L94):
  ```
  model Account:
    …
    push_account_id: int  # 64-bit random integer generated by client; unique here.
    last_acked_push_token: str  # The last push token the server acknowledged receipt of from this client.
    push_private_key: PrivateKey  # Private part of the asymmetric key pair generated by the client.
    push_public_key: PublicKey  # Public key corresponding to push_private_key
  ```
- A helper data structure
  ```
  struct PushRegistration:
    token_kind: "apns" | "fcm"
    token: str
    timestamp: datetime
  ```

- The push bouncer maintains a `push_registration_encryption_keys` map
  containing asymmetric key pairs (`{public_key: private_key}`),
  each generated to support key rotation. When a new key pair is created,
  the public key (`bouncer_public_key`) is baked into a new client release.

  To support older clients, the bouncer continues to accept the
  older public keys for a period of time, allowing clients to upgrade.
  Once a sufficient portion of clients have updated, the corresponding
  old keys are removed from the map.

- On the server, add a new table (coexists with `PushDeviceToken`):
  ```
  class zerver.models.push_notifications.PushDevice:
    user: ForeignKey[UserProfile]
    encrypted_push_registration: Ciphertext | None  # A PushRegistration, encrypted with bouncer_public_key. Null once bouncer has confirmed the registration.
    bouncer_public_key: PublicKey | None  # Key used by the client to encrypt a PushRegistration. Null once bouncer has confirmed the registration.
    token_kind: "apns" | "fcm"  # Provided by client.
    push_account_id: int  # 64-bit random integer generated by client; need not be unique.
    bouncer_device_id: RandomID[32] | None  # Generated by bouncer as its unique ID for this record. Null until bouncer has confirmed the registration.
    push_public_key: PublicKey  # Public part of the asymmetric key pair generated by the client.
  ```

- On the push bouncer, add a new table (coexists with `RemotePushDeviceToken`):
  ```
  class zilencer.models.RemotePushDevice:
    device_id: int  # 64-bit integer primary key assigned by bouncer; not random.
    remote_realm: ForeignKey[RemoteRealm] | None  # None for devices using Zulip Cloud.
    realm: ForeignKey[Realm] | None  # None for devices using self-hosted servers.
    token_kind: "apns" | "fcm"
    token: str  # Provided by client.
    push_account_id: int  # 64-bit random integer generated by client; need not be unique.
    expired_time: datetime | None
  ```

## Operation

### To register a new push device for a Zulip account

1. The client checks the [`get-server-settings`](https://zulip.com/api/get-server-settings)
   response to see whether the server advertises the `encrypted_push_notifications`
   capability (or has a new enough feature level, details TBD).

   If it does not, it uses the legacy push notifications registration flow.
   (Note: We’ll likely want settings to require E2E encryption; that can come
   after the feature is complete).

1. If the client already has `push_account_id`, `push_public_key`, and
   `push_private_key` set on the `Account` record for this account,
   it proceeds to the next step.

   Otherwise, the client generates a random 64-bit integer `push_account_id`
   and an asymmetric key pair `push_public_key` and `push_private key`,
   and stores these on the `Account` record.

1. The client builds a JSON object `push_registration` of type `PushRegistration`,
   using the current time for `timestamp`.
   It encrypts this to `bouncer_public_key` as `encrypted_push_registration`.

   The client then makes an API call to the server (authenticated with the user’s
   API key) with arguments `push_account_id`, `encrypted_push_registration`,
   `bouncer_public_key`, `push_public_key`, and `token_kind`.

   If the server responds with a 500 error, the client retries to register.

   The server creates a `PushDevice` instance. It replies to the client with a
   success response, and asynchronously initiates the next step.

   - On success response, the client initiates a timeout to check the `push_account_ids`
     map provided in the [register-queue](https://zulip.com/api/register-queue)
     response (see the [Miscellaneous](#miscellaneous) section for details), to
     verify whether the asynchronous step has succedded. If the status remains
     `"pending"`, the client displays a notice to inform the user that push
     notifications are not yet set up.

   - Next step asynchronous: It ensures that the bouncer service 500ing will just
     cause queueing of those requests for the local server, the mobile client
     doesn’t need to deal with retries here. Handling of 500 is discussed below.

1. The server makes an API call to the push bouncer (authenticated with the
   server’s API key) with arguments `realm_uuid`, `push_account_id`,
   `encrypted_push_registration`, and `bouncer_public_key`.

   The push bouncer:
   1. Uses `bouncer_public_key` to look up the corresponding `private_key`
      in `push_registration_encryption_keys` map; raises a coded `JsonableError`
      if not found.

   1. Decrypts `push_registration` with `private_key` found above.

   1. Check the `timestamp` for liveness, `PUSH_REGISTRATION_LIVENESS_TIMEOUT`
      which equals `24 * 60 * 60` seconds is a good age limit because
      a day is longer than any minor outage.

      A coded `JsonableError` should be used if the timestamp is stale.

   1. Checks that it doesn’t already have a `RemotePushDevice` for
      this `token` and `push_account_id`. If it does already have
      such a record, it returns success with the `device_id` corresponding
      to that record.

      This helps to avoid creating a duplicate record if the server
      previously made the request, didn’t get the success response
      (due to network failure or whatever), and retried.

   1. Creates a `RemotePushDevice` instance, generating a `device_id`.

   **On success**, the bouncer replies to the server with `device_id`.
   The server stores this `device_id` in the `bouncer_device_id` field
   of the corresponding `PushDevice` record and sets its `encrypted_push_registration`
   and `bouncer_public_key` fields to `null`. Once `bouncer_device_id` is set
   `encrypted_push_registration` and `bouncer_public_key` is no longer used,
   so they are safely cleared at this point.

   **On error**:
   - If the error is due to an invalid `bouncer_public_key`, don't retry
     and forget the `push_account_id`. Include an additional `reason`
     field with the value `"invalid bouncer_public_key"` in the event
     sent to remove the `push_account_id` from the `push_account_ids`
     map (see the [Miscellaneous](#miscellaneous) section).

     The client uses the `reason` field to inform the user that they
     need to update the app to continue using push notifications.

   - If it's a liveness error, don't retry and forget the `push_account_id`.
     The error is logged on the server and is also sent via email to the admin.

   - Otherwise, the server keeps retrying for `PUSH_REGISTRATION_LIVENESS_TIMEOUT` seconds.

   Forgetting the `push_account_id` causes the client to retry from scratch,
   if it’s still in use. That way if the client keeps being used, we keep
   retrying and keep sending the server admin error messages about it
   — appropriately so — but we don’t accumulate ghost clients.

### To send a notification

1. The server uses `token_kind` to determine whether to prepare an FCM-style or
   an APNs-style payload for a given device.

1. The server encrypts the notification content to `push_public_key` as `encrypted_content`.

1. The server makes a batched API call to the push bouncer (authenticated
   with the server’s API key) with arguments `device_id` and `encrypted_content`.
   - (That is, the HTTP request has a list of `(device_id, encrypted_content)` pairs.)
   - (It’s OK, just inefficient, if all batches generated by the server are,
     in practice, 1 notice in an initial version)

1. The push bouncer sends a push notification to the client via APNs or FCM
   using `token_kind` and `token`, with a payload including `push_account_id`
   and `encrypted_content`.

1. The client uses `push_account_id` to look up the right `push_private_key`,
   decrypts `encrypted_content` with it, and ends up with the notification
   to process.

### Miscellaneous

- For Zulip Cloud, a background fact about the push bouncer is that it runs
  on the same server and database as the main application; it’s not a separate
  service. So, as an optimization, we skip the HTTP request and instead invoke
  the bouncer functionality through Python function calls within the server codebase.

  To keep things conceptually similar to the self-hosted case with the fewest
  different scenarios to think through (reducing the risk of bugs), we avoid
  optimizations like sending requests directly to FCM/APNs from the server
  without involving bouncer codepath.

- If APNs or FCM indicates to the push bouncer that the token is invalid
  or expired, the push bouncer sets `expired_time` to now. In that case
  — or if the push bouncer gets a notification for an invalid device or
  a device with `expired_time` already set — it returns an error to the server
  that the `device_id` is no longer valid, and the server removes it.
  
- The server gives the client a map of the user’s currently valid `push_account_id`s
  and their registration status ("active", "pending") with the bouncer
  as part of the [register-queue](https://zulip.com/api/register-queue)
  response, and keeps it updated through events.
  - This allows the client to determine if the `push_account_id` it has
    locally for the account is missing on the `push_account_ids` map.
    If missing, it knows it needs to reregister the push device.
    This data helps the client to show a notice to the user if
    the server continues to retry the registration with the bouncer
    (for `PUSH_REGISTRATION_LIVENESS_TIMEOUT` seconds).

  - The status would be useful for a troubleshooting UI.

  - It can also support a UI for showing the user what devices they have
    connected, and revoking any they aren’t using.

- The push bouncer can garbage-collect `RemotePushDevice` records whose
  `expired_time` is sufficiently far in the past, using a longer threshold
  than `PUSH_REGISTRATION_LIVENESS_TIMEOUT`. (Keeping them around for that
  threshold allows us to avoid angering APNs/FCM with repeat notification
  attempts to tokens it already rejected.)
  - Likely a first version might just have a TODO comment on this point.

- Configure a cron job that queries the bouncer to get a list of device IDs
  from the `RemotePushDevice` table where `expired_time` is set, and remove
  these devices from `PushDevice`.

- If the client’s device token changes:
  - Repeat the procedure to register a new push device. Use a fresh `push_account_id`.
  - Optionally try to tell the server to forget the old token.
    (Optional because we expect APNs/FCM to report the token to the bouncer
    as invalid in this case.)

### Background info

What is a “push token”?

The push token is a shared secret between
- APNs/FCM, which generates it
- the app as installed on the given device
- “the” app server (more on this below), which is expected to get
  it from the app on the device.

The app server’s possession of this shared secret is what enables it
to get APNs or FCM to deliver notification-messages to the device.

For Zulip, of course, there are many app servers. But effectively APNs and FCM,
as seen in this concept of the push token, assume that each app has (at most)
a single backend, run by the same people who publish the app. They’re not
designed for the concept of independent self-hosted servers which a single app
talks to. That’s why Zulip’s push bouncer service is needed in the first place.

So “the app server” from APNs or FCM’s perspective is the push bouncer,
not the actual Zulip app server the user is using. As a result, the push token
is only needed by the push bouncer, and the design above has the client
encrypt it so that only the push bouncer sees it, not the Zulip app server.

See also [our doc comment](https://github.com/zulip/zulip-flutter/blob/ec9aa351b3050a0fa3e467007826576110fdbf99/lib/notifications/receive.dart#L42-L51):
```
/// The FCM registration token for this install of the app.
///
/// This is unique to the (app, device) pair, but not permanent.
/// Most often it's the same from one run of the app to the next,
/// but it can change either during a run or between them.
///
/// See also:
///  * Upstream docs on FCM registration tokens in general:
///    https://firebase.google.com/docs/cloud-messaging/manage-tokens
```
