- ZAP PR: [zulip/zulip-architecture#2](https://github.com/zulip/zulip-architecture/pull/2)

# Summary

Proposal to add end-to-end encryption for mobile push notifications.

# Motivation

Currently, the Zulip Push Notification Forwarding Service receives
(but does not store or log) the contents of individual mobile push notifications.

Adding end-to-end encryption for push notifications will ensure that the
actual message content does not need to be readable by the push notification
bouncer (or Google/Apple's servers, for that matter).

# Detailed design

## High-Level Plan

- Client checks the server if it supports E2E encryption. If it doesn't,
  use the legacy push notification registration flow.

- Client generates an asymmetric key pair (public and private key).
  It stores the private key securely and makes an API call to the server
  with the public key to register itself for push notifications.

- While sending notification, the server encrypts the notification content
  to the public key from above and sends it to push bouncer.
  Push bouncer forwards it to FCM/APNs.

- Client receives the notification via FCM/APNs and decrypts the content
  using the private key it stored earlier.

## Data model

- On the client, include the following fields on [the Account type](https://github.com/zulip/zulip-flutter/blob/ec9aa351b3050a0fa3e467007826576110fdbf99/lib/model/database.dart#L66-L94):
  ```
  model Account:
    …
    push_account_id: int  # 64-bit random integer generated by client; unique here.
    last_acked_push_token: str  # The last push token the server acknowledged receipt of from this client.
    push_private_key: PrivateKey  # Private part of the asymmetric key pair generated by the client.
  ```
- A helper data structure
  ```
  struct PushRegistration:
    token_kind: "apns" | "fcm"
    token: str
    timestamp: datetime
  ```
- On the server, add a new table (parallel to `PushDeviceToken`):
  ```
  class zerver.models.push_notifications.PushDevice:
    user: ForeignKey[UserProfile]
    encrypted_push_registration: Ciphertext  # A PushRegistration, encrypted with bouncer_key.
    push_account_id: int  # 64-bit random integer generated by client; need not be unique.
    bouncer_device_id: RandomID[32] | None  # Generated by bouncer as its unique ID for this record. Null until bouncer has confirmed the registration.
    push_public_key: PublicKey  # Public part of the asymmetric key pair generated by the client.
    last_accessed: datetime  # The last time it was accessed to send notification.
  ```
- On the push bouncer, add a new table (parallel to `RemotePushDeviceToken`):
  ```
  class zilencer.models.RemotePushDevice:
    device_id: int  # 64-bit integer primary key assigned by bouncer; not random.
    realm: ForeignKey[RemoteRealm]
    token_kind: "apns" | "fcm"
    token: str  # Provided by client.
    push_account_id: int  # 64-bit random integer generated by client; need not be unique.
    expired_time: datetime | None
  ```

- Make sure to correctly maintain the foreign key from `PushDevice`​ to
  `UserProfile` during export/import. If not done carefully, it can leak
  notifications to the wrong recipients.

- Zulip Cloud doesn't use a third-party bouncer. To keep things conceptually
  similar to the self-hosted case with the fewest different scenarios to think
  through (reducing the risk of bugs), add a new table on the server (parallel
  to `RemotePushDevice` added in the previous step).

- We probably also need a `zerver.models.push_notifications.PushDevice`
  for Zulip Cloud use with no third-party bouncer? Or we could make Cloud use a bouncer.

- Additionally, the push bouncer has an asymmetric key `bouncer_key`,
  of which the public part is baked into clients.

## Operation

### To register a new push device for a Zulip account

1. The client checks the [`get-server-settings`](https://zulip.com/api/get-server-settings)
   response to see whether the server advertises the `encrypted_push_notifications`
   capability (or has a new enough feature level, details TBD).

   If it does not, it uses the legacy push notifications registration flow.
   (Note: We’ll likely want settings to require E2E encryption; that can come
   after the feature is complete).

1. The client generates a random 64-bit integer `push_account_id`.
   It builds a JSON object `push_registration` of type `PushRegistration`,
   and encrypts it to `bouncer_key` as `encrypted_push_registration`.

   It also generates an asymmetric key pair (`push_public_key` and
   `push_private key`).

1. The client makes an API call to the server (authenticated with the user’s
   API key) with arguments `push_account_id`, `encrypted_push_registration`,
   and `push_public_key`.

   The server creates a `PushDevice` instance. It replies to the client with a
   success response, and asynchronously initiates the next step.

   - Next step asynchronous: It ensures that the bouncer service 500ing will just
     cause queueing of those requests for the local server, the mobile client
     doesn’t need to deal with retries here. Handling of 500 is discussed below.

1. The server makes an API call to the push bouncer (authenticated with the
   server’s API key) with arguments `realm_uuid`, `push_account_id`, and `encrypted_push_registration`.

   The push bouncer:
   1. Decrypts `push_registration`.

   1. Check the `timestamp` for liveness, `PUSH_REGISTRATION_LIVENESS_TIMEOUT`
      which equals `24 * 60 * 60` seconds is a good age limit because
      a day is longer than any minor outage.

      A coded `JsonableError` should be used if the timestamp is stale.

   1. Checks that it doesn’t already have a `RemotePushDevice` for
      this `token` and `push_account_id`. If it does already have
      such a record, it returns success with the `device_id` corresponding
      to that record.

      This helps to avoid creating a duplicate record if the server
      previously made the request, didn’t get the success response
      (due to network failure or whatever), and retried.

   1. Creates a `RemotePushDevice` instance, generating a `device_id`.

   **On success**, the bouncer replies to the server with `device_id`.
   The server stores `device_id` in the `PushDevice`.
    
   **On error**:
   - If it's a liveness error, don't retry and forget the `push_account_id`.
     Pass the error to the server admin. The user is notified about this
     error on the client using the `push_account_ids` map provided in the
     [register-queue](https://zulip.com/api/register-queue) response. (Refer
     to the [Miscellaneous](#miscellaneous) section for more details.)

   - Otherwise, the server keeps retrying for `PUSH_REGISTRATION_LIVENESS_TIMEOUT` seconds.

   Forgetting the `push_account_id` causes the client to retry from scratch,
   if it’s still in use. That way if the client keeps being used, we keep
   retrying and keep sending the server admin error messages about it
   — appropriately so — but we don’t accumulate ghost clients.

### To send a notification

1. The server encrypts the notification content to `push_public_key` as `encrypted_content`.

1. The server makes a batched API call to the push bouncer (authenticated
   with the server’s API key) with arguments `device_id` and `encrypted_content`.
   - (That is, the HTTP request has a list of `(device_id, encrypted_content)` pairs.)
   - (It’s OK, just inefficient, if all batches generated by the server are,
     in practice, 1 notice in an initial version)

1. The push bouncer sends a push notification to the client via APNs or FCM
   using `token_kind` and `token`, with a payload including `push_account_id`
   and `encrypted_content`.

1. The client uses `push_account_id` to look up the right `push_public_key`,
   decrypts `encrypted_content` with it, and ends up with the notification
   to process.

### Miscellaneous

- If APNs or FCM indicates to the push bouncer that the token is invalid
  or expired, the push bouncer sets `expired_time` to now. In that case
  — or if the push bouncer gets a notification for an invalid device or
  a device with `expired_time` already set — it returns an error to the server
  that the `device_id` is no longer valid, and the server removes it.
  
- The server gives the client a map of the user’s currently valid `push_account_id`s
  and their registration status ("active", "pending") with the bouncer
  as part of the [register-queue](https://zulip.com/api/register-queue)
  response, and keeps it updated through events.
  - This allows the client to determine if the `push_account_id` it has
    locally for the account is missing on the `push_account_ids` map.
    If missing, it knows it needs to reregister the push device.
    It helps to show an error to the user in case of liveness error.

  - The status would be useful for a troubleshooting UI.

  - It can also support a UI for showing the user what devices they have
    connected, and revoking any they aren’t using.

- The push bouncer can garbage-collect `RemotePushDevice` records whose
  `expired_time` is sufficiently far in the past, using a longer threshold
  than `PUSH_REGISTRATION_LIVENESS_TIMEOUT`. (Keeping them around for that
  threshold allows us to avoid angering APNs/FCM with repeat notification
  attempts to tokens it already rejected.)
  - Likely a first version might just have a TODO comment on this point.

- Configure a cron job that queries the bouncer with a list of `device_ids`
  that have been stale for a week (use `last_accessed` to get the list).
  The bouncer responds with the subset of those IDs for which either an
  `expired_time` is set or no corresponding `RemotePushDevice` record exists.
  Remove these devices from `PushDevice`.

- If the client’s device token changes:
  - Repeat the procedure to register a new push device. Use a fresh `push_account_id`.
  - Optionally try to tell the server to forget the old token.
    (Optional because we expect APNs/FCM to report the token to the bouncer
    as invalid in this case.)

### Background info

What is a “push token”?

The push token is a shared secret between
- APNs/FCM, which generates it
- the app as installed on the given device
- “the” app server (more on this below), which is expected to get
  it from the app on the device.

The app server’s possession of this shared secret is what enables it
to get APNs or FCM to deliver notification-messages to the device.

For Zulip, of course, there are many app servers. But effectively APNs and FCM,
as seen in this concept of the push token, assume that each app has (at most)
a single backend, run by the same people who publish the app. They’re not
designed for the concept of independent self-hosted servers which a single app
talks to. That’s why Zulip’s push bouncer service is needed in the first place.

So “the app server” from APNs or FCM’s perspective is the push bouncer,
not the actual Zulip app server the user is using. As a result, the push token
is only needed by the push bouncer, and the design above has the client
encrypt it so that only the push bouncer sees it, not the Zulip app server.

See also [our doc comment](https://github.com/zulip/zulip-flutter/blob/ec9aa351b3050a0fa3e467007826576110fdbf99/lib/notifications/receive.dart#L42-L51):
```
/// The FCM registration token for this install of the app.
///
/// This is unique to the (app, device) pair, but not permanent.
/// Most often it's the same from one run of the app to the next,
/// but it can change either during a run or between them.
///
/// See also:
///  * Upstream docs on FCM registration tokens in general:
///    https://firebase.google.com/docs/cloud-messaging/manage-tokens
```
