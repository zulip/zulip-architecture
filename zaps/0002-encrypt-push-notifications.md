- ZAP PR: [zulip/zulip-architecture#2](https://github.com/zulip/zulip-architecture/pull/2)

# Summary

This proposal adds end-to-end encryption to Zulip's mobile push
notifications, from the Zulip server to the user's device.

# Motivation

In order to deliver a push notification to the Zulip mobile app
on a user's device, a Zulip server sends the notification to
the [Zulip Mobile Push Notification Service][bouncer-doc]
([permalink][bouncer-doc-permalink]) run by Kandra Labs,
which in turn sends it to a service run by Apple or Google
for delivering to an iOS or Android device respectively.
This structure is [required][bouncer-needed-doc]
by Google's and Apple's respective security models
for mobile push notifications.

The Zulip Mobile Push Notification Service
[does not store or log][bouncer-privacy-doc]
the contents of notifications.
Nevertheless many Zulip server admins would prefer to avoid
notification contents being readable in the first place
by services run by Kandra Labs, Google, or Apple.

Current versions of Zulip offer the option to
[redact message content][bouncer-privacy-doc] from notifications
(so removing the most sensitive information, at the cost of
reducing the value of the notifications)
or to not enable mobile push notifications at all.
By encrypting the notification contents end-to-end, we can make it
possible for server admins to fully enable mobile push notifications
while keeping their contents cryptographically hidden from all parties
in between the individual Zulip server and its users.

[bouncer-doc]: https://zulip.readthedocs.io/en/latest/production/mobile-push-notifications.html
[bouncer-doc-permalink]: https://github.com/zulip/zulip/blob/1a41a13ea3ff8b0cfbf833c0f26b4d6bbf3aaad2/docs/production/mobile-push-notifications.md
[bouncer-needed-doc]: https://github.com/zulip/zulip/blob/1a41a13ea3ff8b0cfbf833c0f26b4d6bbf3aaad2/docs/production/mobile-push-notifications.md#why-a-push-notification-service-is-necessary
[bouncer-privacy-doc]: https://github.com/zulip/zulip/blob/1a41a13ea3ff8b0cfbf833c0f26b4d6bbf3aaad2/docs/production/mobile-push-notifications.md#security-and-privacy


# Design

Each mobile push notification a Zulip server sends will be encrypted
with a public key belonging to the intended user device.
The corresponding private key will have been generated by the Zulip
mobile app on the device, and will remain only on the device.

When a Zulip server sends a notification, the only information it
sends to the Mobile Push Notification Service will be the cryptotext
readable only with the user device's key,
and an identifier the service previously generated.
The service associates this identifier with a minimal set of metadata
needed for sending the notification to the intended device
through Apple's and Google's respective notification services.

There are four parties to this protocol,
of which three are subject to this specification:
* The **client**: an installation of the Zulip mobile app
  on a given user device.
* The **server**: an installation of Zulip Server.
* The **bouncer**: the Zulip Mobile Push Notification Service.
* **APNs or FCM**: the service run by Apple or Google for delivering
  push notifications to iOS or Android devices respectively.

The client and the bouncer interact with APNs or FCM
using the APIs provided by Apple or Google.
This specification describes
how the client and bouncer should use those APIs, and
how the client, server, and bouncer should interact with each other.


## Compatibility

The many different organizations who run Zulip servers choose when to
upgrade their servers, and mobile apps on many users' devices are
upgraded infrequently.  As a result, updated versions of the client,
server, and bouncer will coexist for some time with older client and
server versions which are unaware of this specification.

By default, in this situation notifications will continue to be sent
and delivered without end-to-end encryption, following the same
legacy protocol that Zulip uses today.

Server admins, realm admins, and individual users will also have
the option to require all notifications to be end-to-end encrypted.
The server will offer both a server-level and a realm-level setting;
when either setting is enabled, no unencrypted notifications will be
sent, and older clients will no longer receive notifications.
The client will offer a setting; when enabled, the client will not
register for notifications except through this protocol,
and so will not cause older servers to send it notifications.

Eventually, we will remove support for the old protocol, at which
point these settings will be removed.

## Data structures

Once a given client has logged into a server and the setup phase of
this protocol has been completed, each of the four parties will have
in its own data store a record with metadata used in delivering
notifications from the server to the client.

The data structures in this section are described in a Python-like
pseudocode.

### Client database

Include the following fields on [the Account type](https://github.com/zulip/zulip-flutter/blob/ec9aa351b3050a0fa3e467007826576110fdbf99/lib/model/database.dart#L66-L94):

``` python
class Account:
  # …
  # 64-bit random integer generated by client; unique here.
  push_account_id: int
  # The last push token the server acknowledged receipt of from this client.
  # The client should be careful about case with this field, since
  # APNs at least is case-insensitive.
  last_acked_push_token: str
  # Private part of the asymmetric key pair generated by the client.
  push_private_key: PrivateKey
  # Public key corresponding to push_private_key
  push_public_key: PublicKey
```

The client is responsible for ensuring that these secrets are stored
as securely as possible, including excluding the entire Account table
from device backups. In addition to the security motivation for doing
so, the server relies on there being no duplicate `(user_id,
push_account_id)` pairs.

After a backup/restore process, clients should just register a new
token and key.

### PushRegistration objects

The PushRegistration type appears in the protocol, and an encrypted
form is stored on the server.

``` python
class PushRegistration:
    token_kind: "apns" | "fcm"
    token: str
    timestamp: datetime
```


### Server database

On the server, add a new table (coexisting with legacy `PushDeviceToken`):
``` python
class zerver.models.push_notifications.PushDevice:
    # Generated by bouncer as its unique ID for this record. 
    # Null until bouncer has confirmed the registration.
    bouncer_device_id: RandomID[32] | None  
    # Key used by the client to encrypt a PushRegistration.
    # Null once bouncer has confirmed the registration.
    bouncer_public_key: PublicKey | None
    # A PushRegistration, encrypted with bouncer_public_key. 
    # Null once bouncer has confirmed the registration.
    encrypted_push_registration: Ciphertext | None  
    # 64-bit random integer generated by client. Need not be globally unique.
    push_account_id: int
    # Public part of the asymmetric key pair generated by the client.
    push_public_key: PublicKey
    # Provided by client.
    token_kind: "apns" | "fcm"
    # The user on this server to whom this PushDevice belongs.
    user: ForeignKey[UserProfile]
```


### Bouncer database

On the push bouncer, add a new table (coexisting with legacy `RemotePushDeviceToken`):
``` python
class zilencer.models.RemotePushDevice:
    # 64-bit integer primary key assigned by bouncer; not random.
    device_id: int
    # None for devices using Zulip Cloud.
    remote_realm: ForeignKey[RemoteRealm] | None
    # None for devices using self-hosted servers.
    realm: ForeignKey[Realm] | None
    token_kind: "apns" | "fcm"
    # Provided by client.
    token: str
    # 64-bit random integer generated by client; need not be unique.
    push_account_id: int
    # None unless it has been expired.
    expired_time: datetime | None
```


To support key rotation, the push bouncer also maintains a
`push_registration_encryption_keys` map containing asymmetric key
pairs (`{public_key: private_key}`).

When a new key pair is created, the public key (`bouncer_public_key`)
is baked into a new client release. To support older clients, the
bouncer should continue to accept the older public keys for a period
of time, allowing clients to upgrade. Once a sufficient portion of
clients have updated, the corresponding old keys are removed from the
map.

## Making requests

### From server to bouncer

- For Zulip Cloud, a background fact about the push bouncer is that it
  can run on the same server and database as the main application;
  it’s not a separate service. So, as an optimization, we skip the
  HTTP request and instead invoke the bouncer functionality through
  Python function calls within the server codebase.

  To keep things conceptually similar to the self-hosted case with the
  fewest different scenarios to think through (reducing the risk of
  bugs), we avoid optimizations like sending requests directly to
  FCM/APNs from the server without involving bouncer codepath.

## Operations

### Sending a notification

This operation occurs when the server determines that a notification
should be sent to a given user.

In this specification, a "notification" corresponds to what other
Zulip documentation and code refers to as a "notification-message" or
(in Android contexts) an "FCM message": it's a blob of data which the
server wishes to be delivered to the client via either APNs or FCM, so
that it can arrive promptly even if the user doesn't already have the
mobile app actively running on the device.

The paradigmatic example of a notification-message (a "notification")
is an instruction telling the client about a given Zulip message to be
shown in the device's notifications UI. But it might instead be an
instruction telling the client to remove a given message from the
device's notifications UI, for example because the user read the
message. In the future Zulip might also grow other types of
notification-message to send. The details all go inside the data that
gets encrypted, and so this specification treats all such types
uniformly.

Currently, the Zulip server uses "high" priority for new Zulip
messages and "low" priority for removal notifications. Using high
priority for all notifications would provide somewhat better privacy,
but it is likely not worth the downsides.

TODO sort out "payload" vs "content": any part of the payload
  that needs to differ between APNs and FCM is one that those
  services see, and therefore the bouncer sees.

The steps are:

1. On the server, for each PushDevice belonging to the user:

   1. Look up `PushDevice.bouncer_device_id`, as `device_id`. If the
      value is null, skip this PushDevice as not yet fully registered.

   1. Use `PushDevice.token_kind` to determine whether to
      prepare an FCM-style or an APNs-style payload.

   1. Encrypt the notification content to
      `PushDevice.push_public_key`, as `encrypted_content`.

   1. The result is a pair `(device_id, encrypted_content)`.

1. The server makes an API request to the bouncer
   passing a list of pairs `(device_id, encrypted_content)`.
   The request is authenticated with the server's API key.

   - The server can batch these at its discretion. For example, the
     elements in a given request might be all for one user, or might
     be for several users if an @-mention causes notifications to
     several users.

   - The batching (the fact that the bouncer accepts a list of
     notifications in a single request) is purely for efficiency.
     The server might, for simplicity, send each notification
     in a separate request, with no harm to correctness.

1. On the bouncer, after authenticate the server making the request as
   normal, for each notification in the request:

   1. Use `device_id` to find the RemotePushDevice record.

   1. If neither `RemotePushDevice.remote_realm` nor
      `RemotePushDevice.realm` corresponds to the authenticated server
      making the request, fail with error.

   1. Use `RemotePushDevice.token_kind` to identify whether to send
      the notification through APNs or FCM.

   1. Use `RemotePushDevice.push_account_id` and the given
      `encrypted_content` to assemble the APNs or FCM payload.

   1. Make a request to APNs or FCM to send the resulting payload,
      addressed to `RemotePushDevice.token`.

1. On the client, handling the delivered APNs or FCM payload:

   1. Use `push_account_id` to look up the Account record.

   1. Use `Account.push_private_key` to decrypt `encrypted_content`.

   1. Process the resulting plaintext as a notification.

### Registering a client device

This operation occurs after a client logs into a Zulip server and
therefore creates an Account record in its database.

The purpose of the operation is to set the needed fields on Account
and create the needed PushDevice record on the server and
RemotePushDevice record on the bouncer to enable the "sending a
notification" operation above to succeed.

Some steps may happen repeatedly due to retries, as detailed below.

1. The client determines whether the server supports this
   specification, using the information it received in the
   [`get-server-settings`](https://zulip.com/api/get-server-settings)
   response.

   TBD: That information might be expressed as a capability
   `encrypted_push_notifications`, or just as a feature level.

   If the server supports this specification, proceed to the next step.

   Otherwise, if the user has enabled mandatory E2EE in their
   client settings, end the operation and skip the remaining steps.
   The client is responsible for displaying this failure to the user,
   including in the notification troubleshooting UI.

   Otherwise, use the legacy flow for push notifications registration,
   and skip the remaining steps below.

2. On the client:

   If `push_account_id`, `push_public_key`, and `push_private_key` are
   already set on the `Account` record, proceed to the next step.

   Otherwise, generate a random 64-bit integer `push_account_id` and
   an asymmetric key pair `push_public_key` and `push_private_key`.
   Store these on the `Account` record.

3. On the client:

   1. Construct a PushRegistration object, using the current time for
      `timestamp`.

   2. Encode the PushRegistration object as JSON. Encrypt the JSON
      string to `bouncer_public_key`, as
      `encrypted_push_registration`.

   3. Make an API request to the server with arguments `push_account_id`,
      `encrypted_push_registration`, `bouncer_public_key`,
      `push_public_key`, and `token_kind`.

      The request is authenticated with the user’s API key, in the
      same way as other requests the client makes to the server.

   4. If the server responds with a networking or 500 error, the
      client retries to register with its standard retry/backoff
      strategy. Client error handling of other failure modes (E.g.,
      authentication failure) is otherwise TBD.

4. On the server, handling the request from the client:

   1. Create a `PushDevice` record using the provided fields.

   2. Reply to the client with a success response.

   3. Asynchronously (i.e., without waiting for the result before
      responding to the client), initiate the next server step below.

      This step is asynchronous so that the bouncer service being
      unreachable or 500ing will just cause queueing of those requests
      for the local server. Because the local server is expected to
      have reliable network, it's the better place for this
      error-handling. Handling of 500 is discussed below.

5. On the client, upon a success response from the request above:

   Initiate a timeout to check the `push_account_ids`
   map provided in the [register-queue](https://zulip.com/api/register-queue)
   response (see the [In register-queue](in-register-queue) section for details), to
   verify whether the asynchronous step has succeeded. If the status remains
   `"pending"`, the client displays a notice to inform the user that push
   notifications are not yet set up.

6. On the server, make an API call to the push bouncer (authenticated with the
   server’s API key) with arguments `realm_uuid`, `push_account_id`,
   `encrypted_push_registration`, and `bouncer_public_key`.

7. On the bouncer, handling this request from the server:

   1. Use `bouncer_public_key` to look up the corresponding
      `private_key` in `push_registration_encryption_keys` map.  If
      not found, fail with an `INVALID_BOUNCER_PUBLIC_KEY` error code.

   1. Decrypt the given `encrypted_push_registration` with the
      resulting `private_key`, to produce `push_registration`.

   1. Check the `timestamp` for liveness: no older than
      `PUSH_REGISTRATION_LIVENESS_TIMEOUT`.

      The value of `PUSH_REGISTRATION_LIVENESS_TIMEOUT` might be
      1 day, i.e. `24 * 60 * 60` seconds,
      in order to be longer than any minor outage.

      If the timestamp is older than the threshold, then the request
      is stale; fail with an `request_expired` error code.

   1. Look in `RemotePushDevice` for a record with the given
      `token` and `push_account_id`.

      If a record exists, return success, with the `device_id` from
      that record.

      * This helps to avoid creating a duplicate record if the server
        previously made the request, didn’t get the success response
        (due to network failure or whatever), and retried.

   1. Otherwise, create a `RemotePushDevice` record,
      generating a `device_id`.
      Return success with that `device_id`.

8. On the server, handling the bouncer's response to the request:

   * On success, the response contains a `device_id` value.

     In the `PushDevice` record, set `bouncer_device_id` to the given
     `device_id`, and set `encrypted_push_registration`
     and `bouncer_public_key` to null.

     (Once `bouncer_device_id` is set, `encrypted_push_registration`
     and `bouncer_public_key` are no longer of use.)

     The client is now successfully registered and ready to receive
     notifications.

   * On `INVALID_BOUNCER_PUBLIC_KEY` error:

     Delete the `PushDevice` record.

     Use `"INVALID_BOUNCER_PUBLIC_KEY"` as the `error_code` in the
     event sent to remove the `push_account_id` from the
     `push_account_ids` map (see the [In
     register-queue](in-register-queue) section). The client uses this
     `error_code` to inform the user that they need to update the app
     to continue using push notifications.

   * On error due to a stale request:

     Delete the `PushDevice` record.

     This error indicates a long-lasting outage somewhere between the
     server and the bouncer, most likely in either the server or its
     local network configuration.

     Report the error to the server admins in the same way as other
     errors indicating an operational issue, for example in the server
     log and by email.

     User `"REQUEST_EXPIRED"` as the `error_code` in the event sent to
     remove the `push_account_id` from the `push_account_ids` map (see
     the [In register-queue](in-register-queue) section). The client
     uses this `error_code` to know it should attempt registration
     again.

   * On other errors, including 5xx errors and network errors:

     Wait in order to back off, using exponential random backoff
     according to standard practice. Then, asynchronously, retry the
     request.

     Since the server does not have `timestamp`, it cannot check if
     the request is already past the
     `PUSH_REGISTRATION_LIVENESS_TIMEOUT` threshold and therefore
     stale. It is thus reliant on the bouncer to reject such requests.

   (Forgetting the `PushDevice` record will cause the client to retry
   the operation from scratch, if the client is still in use.
   That way if the client keeps being used, we keep retrying and keep
   sending the server admin error messages about it — appropriately so
   — but we don’t accumulate ghost clients.)

   - If a request gets replayed at least
     `PUSH_REGISTRATION_LIVENESS_TIMEOUT` after the original request
     succeeds, this could in theory result in a working `PushDevice`
     being deleted by the `"REQUEST_EXPIRED"` handler. It's the
     responsibility of the server implementation and network layer to
     avoid faults that could have this failure mode.

     There is a known plausible scenario for a replayed request: An
     unlikely race starting with a server backup taken for the purpose
     of testing a Zulip server upgrade while the request was in a
     queue:

       1. The original server successfully completes the registration
          and continues running normally.

       1. The backup is restored on a duplicate server at least
          `PUSH_REGISTRATION_LIVENESS_TIMEOUT` after being taken, and
          notably, the original request is restored as part of this
          process.

       1. The duplicate server would send the request from its queue,
          getting this error and deleting its `PushDevice` record due
          to the stale request error.

       1. However, the bouncer and original server continue running
          normally.

       Thus, that unlikely race would not lead to a fault.

### In register-queue

In the data which the server sends the client in the
[register-queue](https://zulip.com/api/register-queue) response,
and keeps updated via events, we add the following:

* `push_account_ids`, a JSON object, with one entry for each of the
  user's `PushDevice` records.

  * The key is `PushDevice.push_account_id`.

  * The value is an object with the following fields:
    - `status`: `"active"`, `"pending"`, or `"failed"`, representing
      the status of the device's registration.

      The status is pending if `PushDevice.bouncer_device_id` is null,
      and active otherwise.
    - `error_code`: If the status if `"failed"`, the error code
      indicating the cause of the failure.

The client should look up in this map the `push_account_id` value from
the corresponding `Account` record.  It uses the result in two ways:

* This data governs whether to retry registering.  If there is no
  matching `push_account_ids` entry, the client knows the server has
  deleted its registration and it should re-register.

* This data can be used to feed a notifications troubleshooting UI.

  * If the status is active, then registration has succeeded
    and (as far as this piece of information is concerned)
    there is nothing to warn about.

  * If the status is pending, or if there is no matching entry,
    then registration has not succeeded
    and push notifications will not be sent to this client.

    If the `Account` record was created within the last few minutes,
    then this may be normal. Otherwise, it represents at least a
    temporary outage somewhere in the chain, and the user may be
    surprised that push notifications aren't working for them. The
    client might show a warning banner to the user in this case.

### Expired tokens

- If APNs or FCM indicates to the push bouncer that the token is invalid
  or expired, the push bouncer sets `expired_time` to now. In that case
  — or if the push bouncer gets a notification for an invalid device or
  a device with `expired_time` already set — it returns an error to the server
  that the `device_id` is no longer valid, and the server removes it.

- The push bouncer can safely garbage-collect `RemotePushDevice`
  records whose `expired_time` is sufficiently far in the past, using
  a longer threshold than
  `PUSH_REGISTRATION_LIVENESS_TIMEOUT`. (Keeping them around for that
  a while allows us to avoid angering APNs/FCM with repeat
  notification attempts to tokens it already rejected.)

- Configure a cron job that queries the bouncer to get a list of
  device IDs from the `RemotePushDevice` table where `expired_time` is
  sufficiently stale, and remove these devices from `PushDevice`.

### If the client’s device token changes

If a client discovers on startup that its device token has changed and
no longer matches what it has in its `Account` table, the client
should:

- Repeat the procedure to register a new push device. Use a fresh
  `push_account_id`.

- Optionally try to tell the server to forget the old token.
  (Optional because we expect APNs/FCM to report the token to the
  bouncer as invalid in this case.).

### Periodic repeat registrations

The client should also repeat the registration procedure monthly as
detailed in
[#F322](https://github.com/zulip/zulip-flutter/issues/322), to support
garbage-collection for clients that no longer exist.

## Background info

### What is a “push token”?

The push token is a shared secret between

- APNs/FCM, which generates it
- The app as installed on the given device
- “the” app server (more on this below), which is expected to get
  it from the app on the device.

The app server’s possession of this shared secret is what enables it
to get APNs or FCM to deliver notification-messages to the device.

For Zulip, of course, there are many app servers. But effectively APNs and FCM,
as seen in this concept of the push token, assume that each app has (at most)
a single backend, run by the same people who publish the app. They’re not
designed for the concept of independent self-hosted servers which a single app
talks to. That’s why Zulip’s push bouncer service is needed in the first place.

So “the app server” from APNs or FCM’s perspective is the push bouncer,
not the actual Zulip app server the user is using. As a result, the push token
is only needed by the push bouncer, and the design above has the client
encrypt it so that only the push bouncer sees it, not the Zulip app server.

See also [our doc comment](https://github.com/zulip/zulip-flutter/blob/ec9aa351b3050a0fa3e467007826576110fdbf99/lib/notifications/receive.dart#L42-L51):
```
/// The FCM registration token for this install of the app.
///
/// This is unique to the (app, device) pair, but not permanent.
/// Most often it's the same from one run of the app to the next,
/// but it can change either during a run or between them.
///
/// See also:
///  * Upstream docs on FCM registration tokens in general:
///    https://firebase.google.com/docs/cloud-messaging/manage-tokens
```
